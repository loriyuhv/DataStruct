# 数据结构与算法

学自《郝斌数据结构》，以下代码都有改动，因为加入了自己的个人实践以及总结。

## 一、什么叫数据结构

**定义：**我们如何把现实中大量而复杂的问题以特定的数据类型和特定的存储结构保存到主存储器（内存）中，以及在此基础上为实现某个功能（比如查找某个元素，删除某个元素，对所有元素进行排序）而执行的相应操作，这个相应的操作也叫算法。

- 数据结构 = 个体 + 个体的关系
- 算法 = 对存储数据的操作

**算法：**解题的方法和步骤

**衡量算法的标准**

- **时间复杂度：**大概程序要执行的次数，而非执行的时间
- **空间复杂度：**算法执行过程中大概所占用的最大内存
- **难易程度**
- **健壮性**

**数据结构的地位**

- 数据结构是软件中最核心的课程
- 程序 = 数据的存储 + 数据的操作 + 可以被计算机执行的语言

## 二、线性结构 

简介：把所有的结点用一根直线连接起来。

### 2.1 连续存储（数组）

1. **什么叫数组** 元素类型相同、大小相等。

2. **数组的优缺点**（详细看大话数据结构）

**连续存储（数组）的算法**

**coding**

```C
#include<stdio.h>
#include<malloc.h>
#include<stdlib.h>

#define bool char
#define true 1
#define false 0

// 定义了一个数据类型，该数据类型的名字叫做struct Arr
// 该数据类型含有三个成员，分别是pBase, len, cnt
typedef struct Arr {
	int* pBase; /*存储的是数组第一个元素的地址*/
	int len;	/*数组所能容纳的最大元素个数*/
	int cnt;	/*当前数组有效元素个数*/
}*pArr, Arr;

void init_arr(pArr p, int len);				/*初始化函数声明*/
bool append_arr(pArr p, int val);			/*追加函数声明*/
bool insert_arr(pArr p, int pos, int e);	/*插入函数声明*/
bool delete_arr(pArr p, int pos, int* e);	/*删除函数声明*/
bool is_empty(pArr p);						/*是否为空函数声明*/
bool is_full(pArr p);						/*是否为满函数声明*/
void show_arr(pArr p);						/*遍历函数声明*/
void inversion_arr(pArr p);					/*倒置函数声明*/

int main() {
	Arr arr;
    init_arr(&arr, 6); /*为什么初始化，因为类型struct Arr里的三个成员都是垃圾值*/
	return 0;
}
```

#### 2.1.1 初始化

**coding**

```C
void init_arr(pArr p, int len) {
	p->pBase = (pArr)malloc(sizeof(int) * len);
	if (NULL == p->pBase) {
		printf("动态内存分配失败！！！\n");
		exit(-1);
	}
	p->len = len;
	p->cnt = 0;
	return;
}
```

#### 2.1.2 元素空满

**coding**

```C
bool is_empty(pArr p) {	/*判断数组为空函数*/
	if (p->cnt == 0)
		return true;
	else
		return false;
}
bool is_full(pArr p) { /*判断数组为满函数*/
	if (p->cnt == 0)
		return true;
	else
		return false;
}
```

#### 2.1.3 追加元素

**coding**

```C
bool append_arr(pArr p, int val) {
	if (is_full(p)) /*判断数组是否已满*/
		return false;
	p->pBase[p->cnt] = val;
	p->cnt++;
	return true;
}
```

**测试**(main函数)

```C
int main() {
    init_arr(&arr, 6); /*初始化数组，并且长度为6*/
    for (int i = 0; i < 7; i++) { /*插入元素1 - 7*/
        if (append_arr(&arr, i + 1))
            printf("追加数值%d成功！！！\n", i + 1);
        else
            printf("追加数值%d失败！！！\n", i + 1);
    }
    show_arr(&arr); /*遍历数组所有元素*/
    return 0;
}
```

**输出结果**

```
追加数值1成功！！！
追加数值2成功！！！
追加数值3成功！！！
追加数值4成功！！！
追加数值5成功！！！
追加数值6成功！！！
追加数值7失败！！！
1       2       3       4       5       6
```

#### 2.1.4 遍历元素

**coding**

```C
void show_arr(pArr p) {
	if (is_empty(p))
		printf("数组为空！！！\n");
	else {
		for (int i = 0; i < p->cnt; i++)
			printf("%d\t", p->pBase[i]);
	}
	printf("\n");
	return;
}
```

#### 2.1.5 插入元素

**coding**

```C
bool insert_arr(pArr p, int pos, int e) {
	int i;
	if (is_full(p))	/*判断函数是否已满*/
		return false;
	if (pos < 1 || pos > p->cnt + 1) /*判断插入位置是否正确*/
		return false;
	if (pos != p->cnt + 1) /*如果插入位置是末尾，直接赋值即可*/
		for (i = p->cnt - 1; i >= pos - 1; i--) /*给要插入的值腾出位置*/
			p->pBase[i + 1] = p->pBase[i];
	p->pBase[pos - 1] = e;
	p->cnt++;
	return true;
}
```

**测试**（main函数）

```C
int main() {
	Arr arr;
	init_arr(&arr, 6); /*初始化数组，并且长度为6*/
	for (int i = 0; i < 4; i++) {
		append_arr(&arr, i + 1);
	}
	printf("插入前：");
	show_arr(&arr);
	if (insert_arr(&arr, 2, 88)) /*把值88插入位置2*/
		printf("位置%d插入数值%d成功！！！\n", 2, 88);
	else
		printf("位置%d插入数值%d失败！！！\n", 2, 88);
	printf("插入后：");
	show_arr(&arr); /*遍历数组所有元素*/
	return 0;
}
```

**输出结果**

```
插入前：1       2       3       4
位置2插入数值88成功！！！
插入后：1       88      2       3       4
```

#### 2.1.6 删除元素

**coding**

```C
bool delete_arr(pArr p, int pos, int* e) {
	if (is_empty(p)) /*判断数组为空*/
		return false;
	if (pos < 1 || pos > p->cnt) /*判断插入位置是否合理*/
		return false;
	*e = p->pBase[pos - 1]; /*将删除的值赋给*e*/
	if (pos != p->cnt)
		for (int i = pos - 1; i < p->cnt; i++)
			p->pBase[i] = p->pBase[i + 1];
	p->cnt--;
	return true;
}
```

**测试**（main函数）

```C
int main() {
	Arr arr;
	init_arr(&arr, 6); /*初始化数组，并且长度为6*/
	int e;
	for (int i = 0; i < 4; i++) {
		append_arr(&arr, i + 1);
	}
	printf("删除前：");
	show_arr(&arr);
	if (delete_arr(&arr, 4, &e)) /*把值88插入位置2*/
	printf("位置%d删除数值%d成功！！！\n", 4, e);
	else
	printf("位置输入不合理或数组为空\n");
	printf("删除后：");
	show_arr(&arr); /*遍历数组所有元素*/
	if (is_empty(&arr)) /*测试数组arr是否创建成功*/
		printf("数组为空！！！");
	return 0;
}
```

**输出结果**

```
删除前：1       2       3       4
位置4删除数值4成功！！！
删除后：1       2       3
```

#### 2.1.7 倒置元素

**coding**

```C
void inversion_arr(pArr p) {
	/*方法一*/
	/*int i = 0, j = p->cnt - 1, t;
	while (i < j) {
		t = p->pBase[i];
		p->pBase[i] = p->pBase[j];
		p->pBase[j] = t;
		i++;
		j--;
	}
	return;*/
	/*方法二*/
	int i = 0, n = p->cnt - 1, t;
	for (; i <= n / 2; i++) {
		t = p->pBase[i];
		p->pBase[i] = p->pBase[n - i];
		p->pBase[n - i] = t;
	}
	return;
}

```

**测试**（main函数）

```C
int main() {
	Arr arr;
	init_arr(&arr, 6); /*初始化数组，并且长度为6*/
	for (int i = 0; i < 4; i++) {
		append_arr(&arr, i + 1);
	}
	printf("倒置前：");
	show_arr(&arr);
	inversion_arr(&arr);
	printf("倒置后：");
	show_arr(&arr);
	if (is_empty(&arr)) /*测试数组arr是否创建成功*/
		printf("数组为空！！！");
	return 0;
}
```

**输出结果**

```
倒置前：1       2       3       4
倒置后：4       3       2       1
```



### 2.2 离散存储(链表）

**定义：**

- n个节点离散分配；
- 彼此通过指针相连；
- 每个节点只有一个前驱节点，每个节点只有一个后续节点；
- 首节点没有前驱节点，尾节点没有后续节点。

**专业术语**

- 首节点：第一个有效节点

- 尾节点：最后一个有效节点

- 头节点：第一个有效节点之前的节点

  **注意：**头结点并不存放有效数据，加头结点的目的主要是为了方便对链表的操作

- 头指针：指向头结点的指针变量

- 尾指针：指向尾结点的指针变量

如果希望通过一个函数来对链表进行处理，我们至少需要接收链表的哪些参数：只需要一个参数：**头指针**。
因为我们通过头指针可以推算出链表的其他所有信息

**分类**

- 单链表
- 双链表：每一个节点有两个指针域
- 循环链表：能通过任何一个节点找到其他所有的节点。
- 非循环链表

**算法**

- 狭义的算法是与数据存数方式密切相关。

- 广义的算法是数据的存储方式无关。

  泛型：利用某种技术大到的效果就是：不同的存数方式，执行的操作时一样的。

常见算法：遍历、查找、清空、销毁、求长度和排序等。 

**离散存储（单链表）算法 **

**coding**

```C
#include<stdio.h>
#include<malloc.h>
#include<stdlib.h>

typedef struct Node {
	int data;	/*数据域*/
	struct Node* pNext;	/*指针域*/
}*PNODE, NODE; 
/* 
1) NODE = struct Node
2) PNODE = struct Node*
*/

int main() { 
	return 0;
}
```



#### 2.1.1 创建链表

```C
PNODE create_list() {
	int len; /* 用来存放节点的个数 */
	int i;
	int val; /* 用来临时存放用户输入结点的值 */

	/* 分配了一个不存放有效数据的头节点 */
	PNODE pHead = (PNODE)malloc(sizeof(NODE));
	if (pHead == NULL) {
		printf("分配失败，程序终止！！！\n");
		exit(-1);
	}
	PNODE pTail = pHead;
	pTail->pNext = NULL;

	printf("请输入您要生成链表节点的个数：len = ");
	scanf_s("%d", &len);
	loop:if (len < 1) {
		printf("输入错误，请输入大于1的整数：");
		scanf_s("%d", &len);
		goto loop;
	}

	for (i = 0; i < len; i++) {
		printf("请输入%d个节点的值：", i + 1);
		scanf_s("%d", &val);

		PNODE pNew = (PNODE)malloc(sizeof(NODE));
		if (pNew == NULL) {
			printf("分配失败，程序终止！！！\n");
			exit(-1);
		}
		pNew->data = val;
		pTail->pNext = pNew;
		pNew->pNext = NULL;
		pTail = pNew;
	}

	return pHead;
}
```

测试（main函数）

```C
int main() { 
	PNODE pHead = NULL;
	// 创建一个非循环单链表，并将该链表的头结点的地址赋给pHead
	pHead = create_list();
	if (is_empty(pHead)) {
		printf("链表为空！！！\n");
	}

	return 0;
}
```

#### 2.1.2 元素空满

```C
bool is_empty(PNODE pHead) {
	if (pHead->pNext == NULL) {
		return true;
	}
	else {
		return false;
	}
}
```

#### 2.1.3 追加元素

```C
```





#### 2.1.4 遍历元素

```C
```





#### 2.1.5 插入元素








//int main() {
//	PNODE pHead = NULL;
//	// 创建一个非循环单链表，并将该链表的头结点的地址赋给pHead
//	pHead = create_list(); 
//	//printf("%x\n", pHead);
//	//is_empty(pHead);
//	//printf("链表长度为：%d\n", length_list(pHead));
//	//sort_list(pHead);
//	//insert_list(pHead, 1, 88);
//	int val;
//	traverse_list(pHead);
//	delete_list(pHead, 3, &val);
//	printf("删除了元素%d\n", val);
//	traverse_list(pHead);
//	return 0;
//}
//

//void traverse_list(PNODE pHead) {
//	PNODE p = pHead->pNext;
//
//	while (NULL != p) {
//		printf("%d\t", p->data);
//		p = p->pNext;
//	}
//	printf("\n");
//	return;
//}
//bool is_empty(PNODE pHead) {
//	if (pHead->pNext == NULL) {
//		printf("链表为空！！！\n");
//		return true;
//	}
//	else {
//		printf("链表不空！！！");
//		return false;
//	}
//}
//int length_list(PNODE pHead) {
//	PNODE p = pHead->pNext;
//	int i = 0;
//	while (NULL != p) {
//		i++;
//		p = p->pNext;
//	}
//	return i;
//}
//
//bool insert_list(PNODE pHead, int pos, int val) {
//	int i = 0;
//	PNODE p = pHead;
//	// 1 2 3   2 88   1 88 2 3
//	while (NULL != p && i < pos - 1) {
//		p = p->pNext;
//		i++;
//	}
//	if (i > pos - 1 || NULL == p)
//		return false;
//	PNODE pNew = (PNODE)malloc(sizeof(NODE));
//	if (NULL == pNew) {
//		printf("动态内存分配失败！！！\n");
//		exit(-1);
//	}
//	/*pNew->data = val;
//	PNODE q = p->pNext;
//	p->pNext = pNew;
//	pNew->pNext = q;*/
//	// 改写
//	pNew->data = val;
//	pNew->pNext = p->pNext;
//	p->pNext = pNew;
//	return;
//}
//// 错误 当节点为1个时
//// 输出 
//// 删除了元素-858993460
//// 1
//bool delete_list(PNODE pHead, int pos, int* value) {
//	PNODE p = pHead;
//	int i = 0;
//	while (NULL != p && i < pos - 1) {
//		p = p->pNext;
//		i++;
//	}
//	// 1 2 3  2   1 3
//	// p = 1
//	// 原代码
//	/*if (NULL == p || 1 < pos - 1)
//		return false;*/
//	// 修改后的代码
//	printf("Hello world\n");
//	*value = p->pNext->data;
//	PNODE q = p->pNext->pNext;
//	free(p->pNext);
//	p->pNext = q;
//	return;
//}
//void sort_list(PNODE pHead) {
//	PNODE p, q;
//	int i, j, t, len = length_list(pHead);
//
//	for (i = 0, p = pHead->pNext; i < len - 1; i++, p = p->pNext) {
//		for (j = i + 1, q = p->pNext; j < len; j++, q = q->pNext) {
//			if (p->data > q->data) {
//				t = p->data;
//				p->data = q->data;
//				q->data = t;
//			}
//		}
//	}
//
//}

// 排序（沉底法）

//# include<stdio.h>
//
//int main() {
//	int i, j, t;
//	int a[5] = { 3, 2, 4, 1, 5 };
//
//	for (i = 0; i < 4; i++)
//		for (j = i + 1; j < 5; j++) {
//			if (a[i] < a[j]) {
//				t = a[i];
//				a[i] = a[j];
//				a[j] = t;
//			}
//		}
//
//	for (i = 0; i <= 4; i++)
//		printf("%d\t", a[i]);
//}



// 2) 离散存储(链表）
// a. 定义：
	// n个节点离散分配；
	// 彼此通过指针相连；
	// 每个节点只有一个前驱节点，每个节点只有一个后续节点；
	// 首节点没有前驱节点，尾节点没有后续节点
	// 专业术语
		// 首节点：
			// 第一个有效节点
		// 尾节点：
			// 最后一个有效节点
		// 头节点：
			// 第一个有效节点之前的节点；
			// 头结点并不存放有效数据
			// 加头结点的目的主要是为了方便对链表的操作
		// 头指针：
			// 指向头结点的指针变量
		// 尾指针
			// 指向尾结点的指针变量
	// 如果希望通过一个函数来对链表进行处理，
	// 我们至少需要接收链表的哪些参数：
		// 只需要一个参数：头指针
		// 因为我们通过头指针可以推算出链表的其他所有信息

//# include<stdio.h>
//
//typedef struct Node {
//	int data; // 数据域
//	struct Node* pNext; // 指针域
//}*PNODE, NODE; // NODE 等价于 struct Node
//// PNODE 等价于 struct Node*
//
//int main() {
//
//	return 0;
//}

// b. 分类
	// 单链表
	// 双链表
	// 每一个节点有两个指针域
	// 循环链表
	// 能通过任何一个节点找到其他所有的节点。
	// 非循环链表
// c. 算法
	// 狭义的算法是与数据存数方式密切相关。
	// 广义的算法是数据的存储方式无关。
	// 泛型：利用某种技术大到的效果就是：不同的存数方式，执行的操作时一样的。
	// 遍历
	// 查找
	// 清空
	// 销毁
	// 求长度
	// 排序 
// coding
//# include<stdio.h>
//# include<malloc.h>
//# include<stdlib.h>
//
//# define bool char
//# define true 1
//# define false 0
//
//typedef struct Node {
//	int data;	// 数据域
//	struct Node* pNext;	// 指针域
//}*PNODE, NODE;
//
//PNODE create_list();
//void traverse_list(PNODE pHead);
//bool is_empty(PNODE pHead);
//int length_list(PNODE pHead);
//bool insert_list(PNODE pHead, int pos, int val);
//bool delete_list(PNODE pHead, int pos, int* value);
//void sort_list(PNODE pHead);
//
//int main() {
//	PNODE pHead = NULL;
//	// 创建一个非循环单链表，并将该链表的头结点的地址赋给pHead
//	pHead = create_list(); 
//	//printf("%x\n", pHead);
//	//is_empty(pHead);
//	//printf("链表长度为：%d\n", length_list(pHead));
//	//sort_list(pHead);
//	//insert_list(pHead, 1, 88);
//	int val;
//	traverse_list(pHead);
//	delete_list(pHead, 3, &val);
//	printf("删除了元素%d\n", val);
//	traverse_list(pHead);
//	return 0;
//}
//
//PNODE create_list() {
//	int len;	// 用来存放节点的个数
//	int i;
//	int val; // 用来临时存放用户输入节点的值。
//	
//	// 分配了一个不存放有效数据的头结点
//	PNODE pHead = (PNODE)malloc(sizeof(NODE));
//	printf("%x\n", pHead);
//
//	if (NULL == pHead) {
//		printf("分配失败，程序终止！！！\n");
//		exit(-1);
//	}
//
//	PNODE pTail = pHead;
//	pTail->pNext = NULL;
//	printf("%x\n", pTail);
//
//	printf("请输入您需要生成的链表节点的个数：len=");
//	scanf_s("%d", &len);
//
//	loop: if (len < 1) {
//		printf("输入错误，请输入大于1的整数：");
//		scanf_s("%d", &len);
//		goto loop;
//	}
//
//	for (i = 0; i < len; i++) {
//		printf("请输入第%d个节点的值：", i + 1);
//		scanf_s("%d", &val);
//
//		PNODE pNew = (PNODE)malloc(sizeof(NODE));
//		printf("第%d个节点地址：%x\n", i + 1, pNew);
//		if (NULL == pNew) {
//			printf("分配失败，程序终止！！！\n");
//			exit(-1);
//		}
//		pNew->data = val;
//		pTail->pNext = pNew;
//		pNew->pNext = NULL;
//		pTail = pNew;
//	}
//	return pHead;
//}
//void traverse_list(PNODE pHead) {
//	PNODE p = pHead->pNext;
//
//	while (NULL != p) {
//		printf("%d\t", p->data);
//		p = p->pNext;
//	}
//	printf("\n");
//	return;
//}
//bool is_empty(PNODE pHead) {
//	if (pHead->pNext == NULL) {
//		printf("链表为空！！！\n");
//		return true;
//	}
//	else {
//		printf("链表不空！！！");
//		return false;
//	}
//}
//int length_list(PNODE pHead) {
//	PNODE p = pHead->pNext;
//	int i = 0;
//	while (NULL != p) {
//		i++;
//		p = p->pNext;
//	}
//	return i;
//}
//
//bool insert_list(PNODE pHead, int pos, int val) {
//	int i = 0;
//	PNODE p = pHead;
//	// 1 2 3   2 88   1 88 2 3
//	while (NULL != p && i < pos - 1) {
//		p = p->pNext;
//		i++;
//	}
//	if (i > pos - 1 || NULL == p)
//		return false;
//	PNODE pNew = (PNODE)malloc(sizeof(NODE));
//	if (NULL == pNew) {
//		printf("动态内存分配失败！！！\n");
//		exit(-1);
//	}
//	/*pNew->data = val;
//	PNODE q = p->pNext;
//	p->pNext = pNew;
//	pNew->pNext = q;*/
//	// 改写
//	pNew->data = val;
//	pNew->pNext = p->pNext;
//	p->pNext = pNew;
//	return;
//}
//// 错误 当节点为1个时
//// 输出 
//// 删除了元素-858993460
//// 1
//bool delete_list(PNODE pHead, int pos, int* value) {
//	PNODE p = pHead;
//	int i = 0;
//	while (NULL != p && i < pos - 1) {
//		p = p->pNext;
//		i++;
//	}
//	// 1 2 3  2   1 3
//	// p = 1
//	// 原代码
//	/*if (NULL == p || 1 < pos - 1)
//		return false;*/
//	// 修改后的代码
//	printf("Hello world\n");
//	*value = p->pNext->data;
//	PNODE q = p->pNext->pNext;
//	free(p->pNext);
//	p->pNext = q;
//	return;
//}
//void sort_list(PNODE pHead) {
//	PNODE p, q;
//	int i, j, t, len = length_list(pHead);
//
//	for (i = 0, p = pHead->pNext; i < len - 1; i++, p = p->pNext) {
//		for (j = i + 1, q = p->pNext; j < len; j++, q = q->pNext) {
//			if (p->data > q->data) {
//				t = p->data;
//				p->data = q->data;
//				q->data = t;
//			}
//		}
//	}
//
//}

// 排序（沉底法）

//# include<stdio.h>
//
//int main() {
//	int i, j, t;
//	int a[5] = { 3, 2, 4, 1, 5 };
//
//	for (i = 0; i < 4; i++)
//		for (j = i + 1; j < 5; j++) {
//			if (a[i] < a[j]) {
//				t = a[i];
//				a[i] = a[j];
//				a[j] = t;
//			}
//		}
//
//	for (i = 0; i <= 4; i++)
//		printf("%d\t", a[i]);
//}


// 3) 线性结构的两种应用之一 栈
// 4) 线性结构的两种应用之一 队列
// 专题: 递归
// a. 1+2+3+4+...+100的和
// b. 求阶乘
// c. 汉若塔
// d. 走迷宫

// 模块二：非线性结构
// 树
// 图

// 模块三 查找和排序
// a. 折半查找
// b. 排序